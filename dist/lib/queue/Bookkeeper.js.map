{"version":3,"sources":["../../../lib/queue/Bookkeeper.ts"],"names":[],"mappings":"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","file":"Bookkeeper.js","sourceRoot":"","sourcesContent":["import {IQueueConfiguration} from './IQueueConfiguration';\nimport {IBookkeepingInfo} from './IBookkeepingInfo';\nimport {Node} from './Node';\n\n/**\n * This class keeps track of the start, end and size of the queue\n * stored in local storage. It allows nodes to be created and removed.\n */ \nexport class Bookkeeper<ILogEntry> {\n  private _info: IBookkeepingInfo; \n  private _added: Array<Node<ILogEntry>>;\n  private _removed: Array<Node<ILogEntry>>;\n\n  /**\n   * Creates a new Bookkeeper for a queue. It should be initialized using reset method.\n   */\n  constructor(private _config: IQueueConfiguration) {\n  }\n\n  /**\n   * Stores the current state of the queue to local storage.\n   */\n  store() {\n    try {\n      const serializedInfo = JSON.stringify(this._info);\n      // Ideally this would all be inside a transaction {\n      this._removed.forEach(node => node.remove());\n      this._added.forEach((node) => {\n        if(!node.store()) {\n          this._info.sizeInBytes = this._config.maxSizeInBytes; // Maximum limit reached\n          console.warn('ngAlogy: local storage filled up...');\n          let tries = 500; // Set to max tries before giving up\n          while(tries > 0) {\n            if(node.store()) {\n              tries = -1;\n            }\n            tries--;\n          }\n          if(tries >= 0) {\n            console.warn('Error: No more space, and the efforts done to fix it failed :/');\n            throw new Error('No more space');\n          }\n        }\n      });\n      localStorage.setItem(this._config.keyPrefix, serializedInfo);\n    } finally {\n      this._added = [];\n      this._removed = [];\n    }\n  }\n\n  /**\n   * Resets the start, end and size counts to what was last persisted to\n   * local storage.\n   */\n  reset() {\n    this._added = [];\n    this._removed = [];\n    const serializedInfo = localStorage.getItem(this._config.keyPrefix);\n    if (serializedInfo === null) {\n      this._info = {\n        sizeInBytes: 0,\n        startIndex: 0,\n        nextFreeIndex: 0\n      };\n      this.store(); \n    } else {\n      this._info = JSON.parse(serializedInfo);\n    }\n  }\n\n  /**\n   * Returns true if the queue has no elements.\n   */\n  isEmpty() {\n    return this._info.sizeInBytes === 0;\n  }\n\n  /**\n   * Calculates the projected free space. This takes into account modifications.\n   */\n  remainingSpace() {\n    return this._config.maxSizeInBytes - this._info.sizeInBytes;\n  }\n\n  /**\n   * Creates a new node at the end of the queue.\n   * @param value The value to store as an element of the queue.\n   */\n  createNextNode(value: ILogEntry) {\n    const node = new Node<ILogEntry>(this._config, this._info.nextFreeIndex, value);\n    this._info.nextFreeIndex = this._nextIndex(this._info.nextFreeIndex);\n    this._info.sizeInBytes += node.estimatedSize();\n    this._added.push(node);\n    return node;\n  }\n\n  /**\n   * Removes and returns the first stored node. The consumer should check that there is a node to remove first.\n   */\n  deleteFirstNode() {\n    const node = Node.fromLocalStorage<ILogEntry>(this._config, this._info.startIndex);\n    this._info.startIndex = this._nextIndex(this._info.startIndex);\n    this._info.sizeInBytes -= node.estimatedSize();\n    this._removed.push(node);\n    return node;\n  }\n\n  /**\n   * Iterates through the index values of the elements in the queue. These can be used to retrieve the elements.\n   * @param callback The function that will be invoked once for each index value used in the queue.\n   */\n  iterateIndexValues(callback: (index:number) => void) {\n    for(let i = this._info.startIndex; i !== this._info.nextFreeIndex; i = this._nextIndex(i)) {\n      callback(i);\n    }\n  }\n\n  /**\n   * Returns the next index value (modulo MAX_SAFE_INTEGER).\n   * @param index The previous index value.\n   */\n  _nextIndex(index: number) {\n    const MAX_SAFE_INTEGER = 9007199254740991;\n    return (index + 1) % MAX_SAFE_INTEGER;\n  }\n}\n"]}
{"version":3,"file":"Bookkeeper.js","sourceRoot":"","sources":["../../../lib/queue/Bookkeeper.ts"],"names":[],"mappings":"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","sourcesContent":["import {IQueueConfiguration} from './IQueueConfiguration';\nimport {IBookkeepingInfo} from './IBookkeepingInfo';\nimport {Node} from './Node';\n\n/**\n * This class keeps track of the start, end and size of the queue\n * stored in local storage. It allows nodes to be created and removed.\n */ \nexport class Bookkeeper<T> {\n  private _info: IBookkeepingInfo; \n  private _added: Array<Node<T>>;\n  private _removed: Array<Node<T>>;\n\n  /**\n   * Creates a new Bookkeeper for a queue. It should be initialized using reset method.\n   */\n  constructor(private _config: IQueueConfiguration) {\n  }\n\n  /**\n   * Stores the current state of the queue to local storage.\n   */\n  store() {\n    try {\n      const serializedInfo = JSON.stringify(this._info);\n      // Ideally this would all be inside a transaction {\n      this._removed.forEach(node => node.remove());\n      this._added.forEach(node => node.store());\n      localStorage.setItem(this._config.keyPrefix, serializedInfo);\n      // }\n    } finally {\n      this._added = [];\n      this._removed = [];\n    }\n  }\n\n  /**\n   * Resets the start, end and size counts to what was last persisted to\n   * local storage.\n   */\n  reset() {\n    this._added = [];\n    this._removed = [];\n    const serializedInfo = localStorage.getItem(this._config.keyPrefix);\n    if (serializedInfo === null) {\n      this._info = {\n        sizeInBytes: 0,\n        startIndex: 0,\n        nextFreeIndex: 0\n      };\n      this.store(); \n    } else {\n      this._info = JSON.parse(serializedInfo);\n    }\n  }\n\n  /**\n   * Returns true if the queue has no elements.\n   */\n  isEmpty() {\n    return this._info.sizeInBytes === 0;\n  }\n\n  /**\n   * Calculates the projected free space. This takes into account modifications.\n   */\n  remainingSpace() {\n    return this._config.maxSizeInBytes - this._info.sizeInBytes;\n  }\n\n  /**\n   * Creates a new node at the end of the queue.\n   * @param value The value to store as an element of the queue.\n   */\n  createNextNode(value: T) {\n    const node = new Node<T>(this._config, this._info.nextFreeIndex, value);\n    this._info.nextFreeIndex = this._nextIndex(this._info.nextFreeIndex);\n    this._info.sizeInBytes += node.estimatedSize();\n    this._added.push(node);\n    return node;\n  }\n\n  /**\n   * Removes and returns the first stored node. The consumer should check that there is a node to remove first.\n   */\n  deleteFirstNode() {\n    const node = Node.fromLocalStorage<T>(this._config, this._info.startIndex);\n    this._info.startIndex = this._nextIndex(this._info.startIndex);\n    this._info.sizeInBytes -= node.estimatedSize();\n    this._removed.push(node);\n    return node;\n  }\n\n  /**\n   * Iterates through the index values of the elements in the queue. These can be used to retrieve the elements.\n   * @param callback The function that will be invoked once for each index value used in the queue.\n   */\n  iterateIndexValues(callback: (index:number) => void) {\n    for(let i = this._info.startIndex; i !== this._info.nextFreeIndex; i = this._nextIndex(i)) {\n      callback(i);\n    }\n  }\n\n  /**\n   * Returns the next index value (modulo MAX_SAFE_INTEGER).\n   * @param index The previous index value.\n   */\n  _nextIndex(index: number) {\n    const MAX_SAFE_INTEGER = 9007199254740991;\n    return (index + 1) % MAX_SAFE_INTEGER;\n  }\n}\n"]}
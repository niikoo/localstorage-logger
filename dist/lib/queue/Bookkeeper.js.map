{"version":3,"file":"Bookkeeper.js","sourceRoot":"","sources":["../../../lib/queue/Bookkeeper.ts"],"names":[],"mappings":"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","sourcesContent":["import {IQueueConfiguration} from './IQueueConfiguration';\r\nimport {IBookkeepingInfo} from './IBookkeepingInfo';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * This class keeps track of the start, end and size of the queue\r\n * stored in local storage. It allows nodes to be created and removed.\r\n */ \r\nexport class Bookkeeper<ILogEntry> {\r\n  private _info: IBookkeepingInfo; \r\n  private _added: Array<Node<ILogEntry>>;\r\n  private _removed: Array<Node<ILogEntry>>;\r\n\r\n  /**\r\n   * Creates a new Bookkeeper for a queue. It should be initialized using reset method.\r\n   */\r\n  constructor(private _config: IQueueConfiguration) {\r\n  }\r\n\r\n  /**\r\n   * Stores the current state of the queue to local storage.\r\n   */\r\n  store() {\r\n    try {\r\n      const serializedInfo = JSON.stringify(this._info);\r\n      // Ideally this would all be inside a transaction {\r\n      this._removed.forEach(node => node.remove());\r\n      this._added.forEach((node) => {\r\n        if(!node.store()) {\r\n          this._info.sizeInBytes = this._config.maxSizeInBytes; // Maximum limit reached\r\n          console.warn('ngAlogy: local storage filled up...');\r\n          let tries = 500; // Set to max tries before giving up\r\n          while(tries > 0) {\r\n            if(node.store()) {\r\n              tries = -1;\r\n            }\r\n            tries--;\r\n          }\r\n          if(tries >= 0) {\r\n            console.warn('Error: No more space, and the efforts done to fix it failed :/');\r\n            throw new Error('No more space');\r\n          }\r\n        }\r\n      });\r\n      localStorage.setItem(this._config.keyPrefix, serializedInfo);\r\n    } finally {\r\n      this._added = [];\r\n      this._removed = [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resets the start, end and size counts to what was last persisted to\r\n   * local storage.\r\n   */\r\n  reset() {\r\n    this._added = [];\r\n    this._removed = [];\r\n    const serializedInfo = localStorage.getItem(this._config.keyPrefix);\r\n    if (serializedInfo === null) {\r\n      this._info = {\r\n        sizeInBytes: 0,\r\n        startIndex: 0,\r\n        nextFreeIndex: 0\r\n      };\r\n      this.store(); \r\n    } else {\r\n      this._info = JSON.parse(serializedInfo);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns true if the queue has no elements.\r\n   */\r\n  isEmpty() {\r\n    return this._info.sizeInBytes === 0;\r\n  }\r\n\r\n  /**\r\n   * Calculates the projected free space. This takes into account modifications.\r\n   */\r\n  remainingSpace() {\r\n    return this._config.maxSizeInBytes - this._info.sizeInBytes;\r\n  }\r\n\r\n  /**\r\n   * Creates a new node at the end of the queue.\r\n   * @param value The value to store as an element of the queue.\r\n   */\r\n  createNextNode(value: ILogEntry) {\r\n    const node = new Node<ILogEntry>(this._config, this._info.nextFreeIndex, value);\r\n    this._info.nextFreeIndex = this._nextIndex(this._info.nextFreeIndex);\r\n    this._info.sizeInBytes += node.estimatedSize();\r\n    this._added.push(node);\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the first stored node. The consumer should check that there is a node to remove first.\r\n   */\r\n  deleteFirstNode() {\r\n    const node = Node.fromLocalStorage<ILogEntry>(this._config, this._info.startIndex);\r\n    this._info.startIndex = this._nextIndex(this._info.startIndex);\r\n    this._info.sizeInBytes -= node.estimatedSize();\r\n    this._removed.push(node);\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Iterates through the index values of the elements in the queue. These can be used to retrieve the elements.\r\n   * @param callback The function that will be invoked once for each index value used in the queue.\r\n   */\r\n  iterateIndexValues(callback: (index:number) => void) {\r\n    for(let i = this._info.startIndex; i !== this._info.nextFreeIndex; i = this._nextIndex(i)) {\r\n      callback(i);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the next index value (modulo MAX_SAFE_INTEGER).\r\n   * @param index The previous index value.\r\n   */\r\n  _nextIndex(index: number) {\r\n    const MAX_SAFE_INTEGER = 9007199254740991;\r\n    return (index + 1) % MAX_SAFE_INTEGER;\r\n  }\r\n}\r\n"]}